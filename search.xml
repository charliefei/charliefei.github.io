<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL系列（一）—— 索引</title>
      <link href="/2024/05/16/mysql-index/"/>
      <url>/2024/05/16/mysql-index/</url>
      
        <content type="html"><![CDATA[<p><strong>索引(index)是帮助MySQL高效获取数据的数据结构</strong>（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库的IO成本</td><td>索引列也是要占用空间的。</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</td><td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。</td></tr></tbody></table><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+树索引</td><td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td></tr><tr><td>Hash索引</td><td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询</td></tr><tr><td>R-Tree（空间索引）</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text（全文索引）</td><td>是一种通过建立倒排索引,快速匹配文档的方式。类似于ES</td></tr><tr><td>不同的存储引擎对于索引结构的支持情况。</td><td></td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-Text索引</td><td>5.6以后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><blockquote><p>[!注意]<br>我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p></blockquote><h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><h4 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h4><p>假如说MySQL的索引结构采用二叉树的数据结构，如果主键是顺序插入的，则会形成一个单向链表，结构如下：<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227190214.png" alt="20240227190214.png"><br>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li><strong>顺序插入时，会形成一个链表，查询性能大大降低。</strong></li><li><strong>大数据量情况下，层级较深，检索速度慢。</strong><h4 id="2-B树"><a href="#2-B树" class="headerlink" title="2. B树"></a>2. B树</h4>B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。<br>以一颗最大度数（max-degree：每个节点的最大子节点个数）为5(5阶)的b-tree为例，那这个B树<strong>每个节点最多存储4个key，5个指针</strong>：<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227190508.png" alt="20240227190508.png"></li></ul><p>数据结构可视化网站-B树。 <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a><br>插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227190932.png" alt="20240227190932.png"><br>特点：</p><ul><li><p>5阶的B树，每一个节点最多存储4个key，对应5个指针。</p></li><li><p>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</p></li><li><p>在B树中，非叶子节点和叶子节点都会存放数据。</p><h4 id="3-B-树"><a href="#3-B-树" class="headerlink" title="3. B+树"></a>3. B+树</h4><p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，其结构示意图：<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227191323.png" alt="20240227191323.png"><br>我们可以看到，两部分：</p></li><li><p>绿色框框起来的部分，是<strong>索引部分，仅仅起到索引数据的作用，不存储数据</strong>。</p></li><li><p>红色框框起来的部分，是<strong>数据存储部分，在其叶子节点中要存储具体的数据</strong>。</p></li></ul><p>B+树 <a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a><br>插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227192308.png" alt="20240227192308.png"><br>B+Tree 与 B-Tree相比，主要有以下三点区别：</p><ul><li>所有的数据都会出现在叶子节点。</li><li>叶子节点形成一个单向链表。</li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li></ul><h5 id="3-1-MySQL中优化之后的B-Tree："><a href="#3-1-MySQL中优化之后的B-Tree：" class="headerlink" title="3.1 MySQL中优化之后的B+Tree："></a>3.1 MySQL中优化之后的B+Tree：</h5><p>MySQL索引数据结构对经典的B+Tree进行了优化。<strong>在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序</strong>。<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227192732.png" alt="20240227192732.png"></p><h4 id="4-MySQL为什么选择B-树，而不是B树"><a href="#4-MySQL为什么选择B-树，而不是B树" class="headerlink" title="4. MySQL为什么选择B+树，而不是B树"></a>4. MySQL为什么选择B+树，而不是B树</h4><p>在MySQL中，B+树被广泛应用于索引结构，因为它支持高效的范围查询和区间扫描，并且有助于减少磁盘I/O操作，从而提高查询效率。为什么MySQL使用B+树而不是B树主要有以下几个原因：</p><ol><li><p>B+树可以更好地利用磁盘预读特性<br>在数据库中，数据通常都存储在磁盘上。而磁盘的读写速度比内存慢很多，因此需要尽量减少磁盘I/O操作。<strong>B+树相对于B树来说，其非叶子节点只存储键值信息，而不存储数据信息，这样可以让非叶子节点能够存储更多的键值信息（查询效率主要取决于树的高度，树越高查询效率越慢，而更多的键值信息可以使B+树相较于B树更宽，继而高度更矮一些），从而使得查询同一层次的所有数据时，能够一次性读入更多的数据块，减少磁盘I/O操作。</strong></p></li><li><p>B+树能够更快地进行范围查询<br>由于B+树的非叶子节点只存储键值信息，而不存储指向数据的指针，因此当进行范围查询时，只需要遍历B+树的叶子节点即可，而不需要遍历非叶子节点，大大加快了查询速度。</p></li><li><p>B+树更适合于数据库索引<br>B+树的叶子节点形成了一个有序链表，使得范围查询更加容易实现。而B树则不支持高效的范围查询，并且为了保持平衡需要维护指向所有数据的指针，导致其空间利用率较低。</p></li><li><p>相较于hash表，B+树可以支持范围查询和排序操作</p><h4 id="5-Hash"><a href="#5-Hash" class="headerlink" title="5. Hash"></a>5. Hash</h4><p>MySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p></li><li><p>结构<br>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227215601.png" alt="20240227215601.png"><br>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227215641.png" alt="20240227215641.png"></p></li><li><p>特点<br>A. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）<br>B. 无法利用索引完成排序操作<br>C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p></li><li><p>存储引擎支持<br>在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="1-基本分类"><a href="#1-基本分类" class="headerlink" title="1. 基本分类"></a>1. 基本分类</h3><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p></li></ol><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对表中主键建立的索引</td><td>默认自动创建, 只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><h3 id="2-InnoDB中分类"><a href="#2-InnoDB中分类" class="headerlink" title="2. InnoDB中分类"></a>2. InnoDB中分类</h3><p>在InnoDB存储引擎中，根据索引的在B+树中存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚簇索引（又称聚集索引，Clustered Index）</td><td>将数据存储与索引放到了一块，<strong>索引结构的叶子节点保存了行数据row</strong></td><td>必须有,而且只有一个</td></tr><tr><td>二级索引（又称普通索引，Secondary Index）</td><td>将数据与索引分开存储，<strong>索引结构的叶子节点关联的是对应的主键id</strong></td><td>可以存在多个</td></tr></tbody></table><h4 id="2-1-聚集索引选取规则"><a href="#2-1-聚集索引选取规则" class="headerlink" title="2.1 聚集索引选取规则:"></a>2.1 聚集索引选取规则:</h4><ul><li>如果存在主键，主键（PRIMARY）索引就是聚集索引。如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。<h4 id="2-2-聚集索引和二级索引的具体结构如下："><a href="#2-2-聚集索引和二级索引的具体结构如下：" class="headerlink" title="2.2 聚集索引和二级索引的具体结构如下："></a>2.2 聚集索引和二级索引的具体结构如下：</h4><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227195131.png" alt="20240227195131.png"></li><li>聚集索引的叶子节点下挂的是这一行的数据 。</li><li>二级索引的叶子节点下挂的是该字段值对应的主键值。<h4 id="2-3-回表查询"><a href="#2-3-回表查询" class="headerlink" title="2.3 回表查询"></a>2.3 回表查询</h4>当我们执行如下的SQL语句时，具体的查找过程是什么样子的<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;Arm&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227195601.png" alt="20240227195601.png"><br>具体过程如下:<br>①. 由于是根据name字段进行查询，所以先根据name=’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。<br>②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。<br>③. 最终拿到这一行的数据，直接返回即可</li></ul><blockquote><p>[!NOTE]<br>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p></blockquote><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ] INDEX index_name <span class="keyword">ON</span> table_name (index_col_name,...);</span><br></pre></td></tr></table></figure><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name ;</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name ;</span><br></pre></td></tr></table></figure><h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><h3 id="1-验证索引效率"><a href="#1-验证索引效率" class="headerlink" title="1. 验证索引效率"></a>1. 验证索引效率</h3><p>在一张拥有1w多条数据的表中</p><ul><li>使用主键索引查询<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227205038.png" alt="20240227205038.png"><br>耗时:<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227205141.png" alt="20240227205141.png"></li><li>不使用任何索引查询<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227205229.png" alt="20240227205229.png"><br>耗时：<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227205306.png" alt="20240227205306.png"><br>比较可知，两者有10倍的差距，数据量更多的情况下，差距会更明显。<h3 id="2-最左前缀法则"><a href="#2-最左前缀法则" class="headerlink" title="2. 最左前缀法则"></a>2. 最左前缀法则</h3>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</li></ul><p>以 tb_user 表为例，我们先来查看一下之前 tb_user 表所创建的索引。<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227205524.png" alt="20240227205524.png"><br>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status。</p><p>对于最左前缀法则指的是，查询时，最左变的列，也就是profession必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。</p><ul><li>索引生效的执行计划：</li></ul><ol><li>联合索引全部生效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>联合索引部分生效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span>;</span><br></pre></td></tr></table></figure></li><li>联合索引部分生效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>以上的这三组测试中，我们发现只要联合索引最左边的字段 profession存在，索引就会生效，只不过索引的长度不同。 而且由以上三组测试，我们也可以推测出profession字段索引长度为47、age字段索引长度为2、status字段索引长度为5</li></ol><ul><li>索引不生效的执行计划</li></ul><ol><li>联合索引不生效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>联合索引不生效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>为不满足最左前缀法则，联合索引最左边的profession不存在，索引不生效</li></ol><ul><li>索引部分失效的执行计划<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>存在profession字段，最左边的列是存在的，索引满足最左前缀法则的基本条件。但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索引的长度就是47。</li></ul><blockquote><p>[!NOTE]<br>当执行SQL语句: <code>explain select * from tb_user where age = 31 and status = &#39;0&#39; and profession = &#39;软件工程&#39;;</code> 时，是否满足最左前缀法则，走不走上述的联合索引，索引长度？（答案：联合索引完全生效，索引长度为54）</p><p>注意: 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p></blockquote><h3 id="3-范围查询"><a href="#3-范围查询" class="headerlink" title="3. 范围查询"></a>3. 范围查询</h3><p>联合索引中，出现范围查询(&gt;, &lt;)，范围查询右侧的列索引失效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227211051.png" alt="20240227211051.png"><br>当范围查询使用 &gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字段是没有走索引的。（profession=47、age=2、status=5)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;=</span> <span class="number">30</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227211258.png" alt="20240227211258.png"><br>当范围查询使用&gt;= 或 &lt;= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引的。</p><blockquote><p>[!NOTE]<br>所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt;</p></blockquote><h3 id="4-索引失效情况"><a href="#4-索引失效情况" class="headerlink" title="4. 索引失效情况"></a>4. 索引失效情况</h3><h4 id="4-1-索引列运算"><a href="#4-1-索引列运算" class="headerlink" title="4.1 索引列运算"></a>4.1 索引列运算</h4><p>不要在索引列上进行运算操作， 索引将失效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 索引生效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 索引失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> <span class="built_in">substring</span>(phone,<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="string">&#x27;15&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-2-字符串不加引号"><a href="#4-2-字符串不加引号" class="headerlink" title="4.2 字符串不加引号"></a>4.2 字符串不加引号</h4><p>字符串类型字段使用时，不加引号，索引将失效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 索引生效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 索引失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">17799990015</span>;</span><br></pre></td></tr></table></figure><h4 id="4-3-模糊查询"><a href="#4-3-模糊查询" class="headerlink" title="4.3 模糊查询"></a>4.3 模糊查询</h4><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 索引生效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;软件%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 索引失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工程&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 索引失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工%&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-4-or连接条件"><a href="#4-4-or连接条件" class="headerlink" title="4.4 or连接条件"></a>4.4 or连接条件</h4><p>用or分割开的条件，当or连接的条件，左右两侧字段都有索引时，索引才会生效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990017&#x27;</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure><p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p><h4 id="4-5-数据分布影响"><a href="#4-5-数据分布影响" class="headerlink" title="4.5 数据分布影响"></a>4.5 数据分布影响</h4><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990005&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br></pre></td></tr></table></figure><p>经过测试我们发现，相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为什么呢？<br>因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃<br>索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p><h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h3><p>尽量使用覆盖索引，减少<code>select *</code>。 那么什么是覆盖索引呢？<strong>覆盖索引是指：查询使用了索引，并需要返回的列，在该索引中已经全部能够找到 。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">select</span>后面的id和profession都可以在索引上找到</span><br><span class="line">explain <span class="keyword">select</span> id, profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span></span><br><span class="line"><span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> id,profession,age, status <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> id,profession,age, status, name <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227213042.png" alt="20240227213042.png"><br>四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的Extra，前面两条SQL的结果为 Using where; Using Index ; 而后面两条SQL的结果为: Using index condition 。</p><table><thead><tr><th>Extra</th><th>含义</th></tr></thead><tbody><tr><td>Using where; Using Index</td><td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</td></tr><tr><td>Using index condition</td><td>查找使用了索引，但是需要回表查询数据</td></tr></tbody></table><p>因为，<strong>在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了</strong>。如果超出这个范围，就需要拿到主键id，再去扫描聚簇索引，再获取额外的数据了，这个过程就是回表。而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。</p><ol><li>表和索引结构示意图<br>id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227213603.png" alt="20240227213603.png"></li><li>执行SQL：<code>select id,name from tb_user where name = &#39;Arm&#39;;</code><br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227213820.png" alt="20240227213820.png"><br>虽然是根据name字段查询，查询二级索引，但是由于查询返回字段为id，name，在name的二级索引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高</li><li>执行SQL：<code>select id,name,gender from tb_user where name = &#39;Arm&#39;;</code><br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227214009.png" alt="20240227214009.png"><br>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。</li></ol><h3 id="6-前缀索引"><a href="#6-前缀索引" class="headerlink" title="6. 前缀索引"></a>6. 前缀索引</h3><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><ul><li>语法<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n)) ;</span><br><span class="line"></span><br><span class="line"># 例如：给tb_user表的email字段建立一个长度为<span class="number">5</span>的前缀索引</span><br><span class="line"><span class="keyword">create</span> index idx_email_5 <span class="keyword">on</span> tb_user(email(<span class="number">5</span>));</span><br></pre></td></tr></table></figure></li><li>前缀长度<br>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user ;</span><br></pre></td></tr></table></figure></li><li>前缀索引的查询流程<br><img src="https://gitee.com/ProgrammerCharlie/picgo/raw/master/images/20240227214440.png" alt="20240227214440.png"><h3 id="7-单列索引与联合索引"><a href="#7-单列索引与联合索引" class="headerlink" title="7. 单列索引与联合索引"></a>7. 单列索引与联合索引</h3></li><li>单列索引：即一个索引只包含单个列。</li><li>联合索引：即一个索引包含了多个列。</li></ul><blockquote><p>[!NOTE]<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。因为就算查询条件中的两个字段都是单列索引，mysql最终也只会选择一个索引来查询，就会导致回表查询，而联合索引不会出现这种情况。</p></blockquote><h3 id="8-索引设计原则"><a href="#8-索引设计原则" class="headerlink" title="8. 索引设计原则"></a>8. 索引设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat远程连接mysql数据库</title>
      <link href="/2022/12/05/mysql-linux/"/>
      <url>/2022/12/05/mysql-linux/</url>
      
        <content type="html"><![CDATA[<h2 id="navicat远程连接mysql数据库"><a href="#navicat远程连接mysql数据库" class="headerlink" title="navicat远程连接mysql数据库"></a>navicat远程连接mysql数据库</h2><h3 id="运行环境及工具"><a href="#运行环境及工具" class="headerlink" title="运行环境及工具"></a>运行环境及工具</h3><ul><li>Navicat</li><li>Mysql 8.0.24（远程服务器内安装的）</li><li>ubuntu_server（vmware fusion虚拟机）</li><li>iterm2（连接操作远程服务器）</li></ul><h3 id="一、修改mysql的远程授权登录设置"><a href="#一、修改mysql的远程授权登录设置" class="headerlink" title="一、修改mysql的远程授权登录设置"></a>一、修改mysql的远程授权登录设置</h3><h4 id="1-登录远程服务器的数据库（使用iterm2）"><a href="#1-登录远程服务器的数据库（使用iterm2）" class="headerlink" title="1. 登录远程服务器的数据库（使用iterm2）"></a>1. 登录远程服务器的数据库（使用iterm2）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p    <span class="comment">## 以root登录数据库 </span></span><br></pre></td></tr></table></figure><h4 id="2-查看mysql服务当前的默认端口"><a href="#2-查看mysql服务当前的默认端口" class="headerlink" title="2. 查看mysql服务当前的默认端口"></a>2. 查看mysql服务当前的默认端口</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql;    ## 选择mysql数据库</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> <span class="keyword">user</span>;    ## 查看用户访问端口</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：root用户默认的是localhost，说明只允许从本地登录mysql服务。而我们要从远程以root用户连接数据库，就必须修改host的值，改为<strong>‘%’</strong>：允许任何ip访问。</p></blockquote><h4 id="3-修改host允许任何ip访问"><a href="#3-修改host允许任何ip访问" class="headerlink" title="3. 修改host允许任何ip访问"></a>3. 修改host允许任何ip访问</h4><p>继续在mysql命令面板输入以下指令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> host <span class="operator">=</span> <span class="string">&#x27;%&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><p>看到以上信息说明修改成功！</p><p>这时再使用之前的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> <span class="keyword">user</span>;    ## 查看用户访问端口</span><br></pre></td></tr></table></figure><p>会看到：root用户的host已经修改为’%’</p><p><strong>注意</strong>：<strong>修改完成后 还需要刷新一下服务配置，不然修改不会生效，并且第4步会执行失败。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;    ## 刷新服务配置项</span><br></pre></td></tr></table></figure><p>显示<strong>Query OK</strong>,表示刷新完成。现在就可以配置我们想要<a href="https://so.csdn.net/so/search?q=%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95&spm=1001.2101.3001.7020">远程登录</a>的用户权限了。</p><h4 id="4-授权root用户进行远程登录"><a href="#4-授权root用户进行远程登录" class="headerlink" title="4. 授权root用户进行远程登录"></a>4. 授权root用户进行远程登录</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;数据库密码&#x27;</span>; </span><br></pre></td></tr></table></figure><p>输入完之后，看到<strong>Query OK</strong>，说明执行成功！</p><blockquote><p><strong>说明</strong>：此命令可以授权任何在mysql数据库user表中的用户以远程登录的方式访问数据库，本例中以’root’作为举例，若想授权其他用户，只需修改’root’的值为指定用户即可，’root_pwd’为’root’用户对应的登录密码，可以修改为你想要授权用户的登录密码。</p></blockquote><h4 id="5-启动本地Navicat连接"><a href="#5-启动本地Navicat连接" class="headerlink" title="5. 启动本地Navicat连接"></a>5. 启动本地Navicat连接</h4><p>打开Navicat客户端，新建mysql连接</p><img src="https://files.catbox.moe/h6bpqf.png">]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iTerm2 安装与配置</title>
      <link href="/2022/12/05/oh-my-zsh/"/>
      <url>/2022/12/05/oh-my-zsh/</url>
      
        <content type="html"><![CDATA[<h1 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h1><h2 id="iterm简介"><a href="#iterm简介" class="headerlink" title="iterm简介"></a>iterm简介</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>iTerm2 是一款完全免费的，专为 Mac OS 用户打造的命令行应用。直接在官网上<a href="https://link.jianshu.com/?t=http://iterm2.com/">http://iterm2.com/</a> 下载并安装即可。</p><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><p>设置ITerm为默认终端</p><img src="https://files.catbox.moe/9t3uym.png" /><h2 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h2><h3 id="1-查看系统有几个shell"><a href="#1-查看系统有几个shell" class="headerlink" title="1. 查看系统有几个shell"></a>1. 查看系统有几个shell</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/shells</span><br></pre></td></tr></table></figure><h3 id="2-切换系统默认shell为zsh"><a href="#2-切换系统默认shell为zsh" class="headerlink" title="2. 切换系统默认shell为zsh"></a>2. 切换系统默认shell为zsh</h3><p>zsh: 拥有语法高亮，命令行tab补全，自动提示符，显示Git仓库状态等功能。</p><p>使用下面命令设置默认shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h3 id="3-安装-oh-my-zsh"><a href="#3-安装-oh-my-zsh" class="headerlink" title="3. 安装 oh my zsh"></a>3. 安装 oh my zsh</h3><p>github地址：<a href="https://link.jianshu.com/?t=https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></p><p>使用 wget 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh</span><br></pre></td></tr></table></figure><p>然后给<code>install.sh</code>添加权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x install.sh</span><br></pre></td></tr></table></figure><p>然后执行<code>install.sh</code>：<code>./install.sh</code><br>如果发现很慢，可以修改为<code>gitee</code>：<br><code>vim install.sh</code>进入编辑状态：<br>找到以下部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default settings</span></span><br><span class="line">ZSH=<span class="variable">$&#123;ZSH:-~/.oh-my-zsh&#125;</span></span><br><span class="line">REPO=<span class="variable">$&#123;REPO:-ohmyzsh/ohmyzsh&#125;</span></span><br><span class="line">REMOTE=<span class="variable">$&#123;REMOTE:-https://github.com/<span class="variable">$&#123;REPO&#125;</span>.git&#125;</span></span><br><span class="line">BRANCH=<span class="variable">$&#123;BRANCH:-master&#125;</span></span><br></pre></td></tr></table></figure><p>然后将中间两行改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPO=<span class="variable">$&#123;REPO:-mirrors/oh-my-zsh&#125;</span></span><br><span class="line">REMOTE=<span class="variable">$&#123;REMOTE:-https://gitee.com/<span class="variable">$&#123;REPO&#125;</span>.git&#125;</span></span><br></pre></td></tr></table></figure><p>然后保存退出：<code>:wq</code><br>重新执行即可。</p><h2 id="配置-zsh"><a href="#配置-zsh" class="headerlink" title="配置 zsh"></a>配置 zsh</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="1-修改主题"><a href="#1-修改主题" class="headerlink" title="1. 修改主题"></a>1. 修改主题</h3><p>zsh主题github地址：<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes">https://github.com/ohmyzsh/ohmyzsh/wiki/themes</a></p><p>在 <code>.zshrc</code> 文件中找到并修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;agnoster&quot;</span></span><br></pre></td></tr></table></figure><p>应用主题需要特殊的字体支持，否则可能会出现乱码情况，这时我们来配置字体：</p><p>1.使用 <a href="https://link.jianshu.com/?t=https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf">Meslo</a> 字体，点开连接点击 view raw 下载字体。</p><p>2.安装字体到系统字体册。</p><p>3.应用字体到iTerm2下，设置自己喜欢看着舒服的字号，我设置的14px（iTerm -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Change Font）。</p><img src="https://files.catbox.moe/0jonxf.png" /><h3 id="2-安装插件"><a href="#2-安装插件" class="headerlink" title="2. 安装插件"></a>2. 安装插件</h3><h4 id="安装-zsh-syntax-highlighting-gt-语法高亮显示"><a href="#安装-zsh-syntax-highlighting-gt-语法高亮显示" class="headerlink" title="安装 zsh-syntax-highlighting -&gt; 语法高亮显示"></a>安装 <code>zsh-syntax-highlighting</code> -&gt; 语法高亮显示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><h4 id="安装-zsh-autosuggestions-gt-命令自动补全"><a href="#安装-zsh-autosuggestions-gt-命令自动补全" class="headerlink" title="安装 zsh-autosuggestions -&gt; 命令自动补全"></a>安装 <code>zsh-autosuggestions</code> -&gt; 命令自动补全</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><h4 id="在-zshrc-中找到并修改"><a href="#在-zshrc-中找到并修改" class="headerlink" title="在 .zshrc 中找到并修改"></a>在 <code>.zshrc</code> 中找到并修改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=(git zsh-syntax-highlighting zsh-autosuggestions)</span><br></pre></td></tr></table></figure><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .zshrc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oh-my-zsh </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
